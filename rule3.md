# 规则3: 良好命名才是最好的文档

显然不能谈论计算机编程而不引用莎士比亚的名言，这已经成为陈词滥调了。然而，这里还是引用《罗密欧与朱丽叶》的快速梗概：罗密欧和朱丽叶是两个相爱的不幸青少年，由于两个家族之间的敌意而无法共度幸福的生活。最终这场爱情对所有人都以悲剧收场。

第二幕第二场，朱丽叶在剧中说出了这部剧中著名台词之五：

“名字有什么关系呢？
玫瑰只因是被称作别的名字，
依旧芳香如故。”

我听过类似的关于代码的观点，通常是同事们对我挑剔的代码审查态度感到不满，因为我会在意变量、函数、成员、源文件、类和结构体名称等等的命名问题。

人们常常会反驳，眼神带着鄙夷，说名称并不真的很重要，重要的是所命名的事物。变量（或函数、类，等等）的真正含义只能通过查看代码才能确定。变量的真相在于它所代表的东西——它是如何被设置的，如何被使用，而不在于它的名字。如果更改变量的名称，它的功能并不会改变。

因此，他们声称，只需选择易于输入的名称，然后开始编码即可。

这些人是错误的。

一件事物的名称是您拥有的第一个和最重要的文档。它是不可避免的，它总是存在的。每当您看到对该物的任何引用时，都是通过其名称。这种持续存在是向读者解释该物是什么的绝佳机会，每次他们看到它时都能理解它。

这种机会决不能浪费。

选择某物的名称时，您的目标很简单——名称应该概括该物体的重要内容，并指导读者如何思考它。如果您在给变量命名，那么该名称应该立即告诉读者变量代表什么。如果你在命名一个函数，那么该名称应该告诉读者这个函数做什么。

听起来很简单，对吧？那么事情怎么会偏离正确的方向呢？实际上有无数种方式，就像天空中的星星一样，但有一些常见的失败模式。

# 不要为最小按键次数进行优化

第一种偏离正确的方向的方式是名称过于简短。请记住，代码被阅读的次数比写入的次数要多得多。在编写代码时很容易忘记这一点，而优化名称易于输入而不是花费额外的努力编写易于阅读的代码。

极端情况下，这会导致超短的变量名称。代码越旧，您越有可能看到这种风格。或者，如果您遇到由一个真正古老的程序员（比如20世纪60年代或70年代开始编程的人）完成的工作，那么您更可能看到单个字母和双字母名称。

我把这看作是“数值方法代码”。我非常喜欢数值方法，但编码风格相当不透明。简而言之：

```go
package rule3

func Cp(
	n int,
	rr []float32,
	ii []float32,
	xr float32,
	xi float32,
	yr *float32,
	yi *float32) {
	rn, in := float32(1.0), float32(0.0)
	*yr, *yi = float32(0), float32(0)
	for i := 0; i <= n; i++ {
		*yr += rr[i]*rn - ii[i]*in
		*yi += ii[i]*rn + rr[i]*in
		rn2 := rn*xr - in*xi
		in = in*xr + rn*xi
		rn = rn2
	}
}

```

很难立即明确其中的意思，对吧？你可以推断出来——代码在复数上求解多项式——但需要一些努力。换成更合适的名称会让事情变得简单很多：

```go
package rule3

func evaluateComplexPolynomial(
	degree int,
	realCoeffs []float32,
	imagCoeffs []float32,
	realX float32,
	imagX float32,
	realY *float32,
	imagY *float32) {
	realXN, imagXN := float32(1.0), float32(0.0)
	*realY, *imagY = float32(0), float32(0)
	for i := 0; i <= degree; i++ {
		*realY += realCoeffs[i]*realXN - imagCoeffs[i]*imagXN
		*imagY += imagCoeffs[i]*realXN + realCoeffs[i]*imagXN
		rn2 := realXN*realX - imagXN*imagX
		imagXN = imagXN*realX + realXN*imagX
		realXN = rn2
	}
}
```

显然，如果你为复数有一个数据类型，这段代码就变得更简单了：

```go
package rule3

import (
	"golang.org/x/exp/constraints"
)

type complex[T constraints.Integer | constraints.Float | constraints.Complex] struct {
	Real T
	Imag T
}

func (c complex[T]) MultiBy(y complex[T]) complex[T] {
	c.Real -= y.Real
	c.Imag += y.Imag
	return c
}

func (c *complex[T]) PlusBy(y complex[T]) {}

func evaluateComplexPolynomialV3(
	terms []complex[float32],
	x complex[float32],
	y *complex[float32]) {
	xN := complex[float32]{Real: 1.0, Imag: 0.0}
	*y = complex[float32]{Real: 0.0, Imag: 0.0}
	for _, term := range terms {
		y.PlusBy(xN.MultiBy(term))
		xN.MultiBy(x)
	}
}
```

现在算法的结构非常清晰了，只要记得复数的工作原理。你需要用区域中的变量y累积每个项乘以域值x的N次方的结果。

## 不要混淆规则

第二种名称出错的方式是不一致性。当代码对如何命名事物没有使用一致的规则时，读者很容易感到困惑。

对于大多数项目来说，一定程度的不一致性难以避免。如果你使用任何外部库，那么你就有麻烦了——除非你的所有依赖项都共享相同的命名规则，并且你愿意在这些规则内工作。比如说，你正在编写一个本地的Windows应用程序，并且你愿意采用Microsoft的命名惯例——那么你的代码就可以是一致的。或者你将使用C++标准模板库并可以接受它们的惯例：仍然是一致的。否则，命名方式存在可见的缝隙，因为使用不同的规则命名的对象进行混合。

想象一下，你有一个向量类，预先为固定数量的元素分配存储空间。这很有用，而且不是C++标准库提供的。假设你的项目有一个简单的对象方法命名方案——驼峰命名法，以动词开头。忽略一堆细节，你的类看起来是这样的：

```go
```

这很简单。append方法添加一个新的元素，empty方法清空整个数组，你还有一些访问器来检查向量中当前元素的数目。但是，如果将这个FixedVector类与标准的C++容器混合使用，情况就不如你想象的那么美好：

```go
```

在这里，你有两个连续的行调用了一个向量的empty方法，但这两个调用执行的是完全不同的操作。第一个调用清空了目标向量，而第二个调用检查源向量是否为空。很容易看出这会造成混淆！

显然，你可以为FixedVector类采用标准模板库（STL）的惯例——你可以将其重命名为fixed_vector，并为其所有方法使用STL风格的名称——但这只是把混乱的线移到了你的项目的其他地方。现在你不仅要求你的程序员适应和使用一套外来的命名惯例，而且还要求他们使用这些惯例编写代码。这是一个更大的任务。

混合使用不同的惯例会导致认知负担的低估。在不同的惯例之间来回切换，需要不断地重新解释你阅读的内容，以确定它必须使用哪套惯例。在这个例子中，这意味着在代码中来回跳跃以确定哪个变量具有哪个类型，因此使用哪个惯例。当然，前提是你知道哪种类型使用哪种惯例！

在Sucker Punch，我们避免了我们的惯例与标准C++容器惯例之间的特定问题，方法是编写我们自己的版本的所有容器类，而不是使用STL版本。这是一个相当极端的解决方案，但它确实消除了很多认知负担——容器类的工作方式就像我们写的所有其他代码一样，因此进入容器类的方法时不会掉入一个陌生的景观。比如，STL中的宏或真正的不受限制的模板魔术。不是在评判，但确实如此。

即使这样，我们也并不完全摆脱外来的惯例，因为我们使用了我们没有编写的代码，例如PlayStation平台库。对于大多数项目，某种程度的混合惯例是不可避免的。关键是在可能的情况下尽量减少混合。如果可能的话，隔离外来体，希望它们的惯例不会泄漏到每个人都处理的代码中。


## 避免自己造成伤害

如果你的团队中的程序员没有使用一致的命名惯例，你们都会为自己创造完全可以避免的问题。一堆不一致的惯例甚至使直接的代码都成为一个难题：

```go
```

我感觉有点不舒服。我很难打出这样的代码，但我在为整个团队牺牲。

这个算法并不是很复杂——我只是通过将窗口分成列和行来排列它们，以大致与目标矩形相同的纵横比填充目标矩形。但我使它变得不必要地难以解释命名选择的含义。

最明显的问题是三到四种不同命名风格的混合，这已经够糟糕的了。但即使在命名更一致的代码中，还会出现另一个问题——随着它传递到函数中，某些变量的名称会发生改变。第一次调用split时，我将x0和x1作为最后两个参数传递。它们将接收窗口新矩形的右侧和左侧。然而，在split函数内部，x0和x1的意义完全不同。

这是一个问题。如果你在单步执行LayoutWindows函数，你有关于x0和x1是什么的心理模型。如果你单步进入split函数，你仍然看到x0和x1——但现在它们意味着完全不同的事情。这个函数使用x和y作为一般的变量名称，就像在代数课上一样。它们与坐标系统没有任何关联，就像在LayoutWindows函数中的x和y一样。一个函数代数，下一个函数笛卡尔坐标——这是认知负荷，它会减慢你的速度并产生错误。

一些在函数调用中重新命名的行为是不可避免的。函数参数往往是表达式的结果，而不仅仅是传递另一个变量。在这个例子中，split的前两个参数是rc->left和rc->right，这些概念在split函数内部不能使用这些名称。你将不得不创建变量名称——但如果你聪明的话，这些变量名称将是left和right，这样在你单步进入函数时更容易追踪它们。

这是同一个函数重新组织了一下，使其更一致和易读：

```go
```

仍然是同一个算法，但更容易理解。一致的命名模式使跟踪工作更容易。通过变量名称仅仅知道代表的概念，而无需检查代码来推断其含义——你可能不知道有关名为rowIndex的变量的所有信息，但你可以肯定它是一行的索引。具体是哪一行，属于什么范畴不是很清楚，但知道它是行索引已经很明显了。

一致地命名索引和计数器还有一些积极的副作用。当你进入divideRange函数时，它也使用index和count作为参数名称。在头脑中将layoutWindows中的colIndex和colCount变量翻译成divideRange函数的index和count参数很容易。我使认知负荷最小化了，特别是与我第一个版本中的x0/x1混乱相比。

这是很常见的情况。如果你有一套一致的命名规则，那么当你在不同函数之间、或者代码库的不同部分之间传递时，类似的东西将会有类似的名称。相同的东西通常会有相同的名称。当你在代码中单步操作，或试图理解不同代码部分如何相互作用时，你不必为一个东西记住一堆名称。只有一个名称——或仅仅一小部分明显相关的名称，比如之前的index+count例子。

# “Don’t Make Me Think”

实际上，你可以通过规则创建一致性更进一步。

保持一致的关键是让所有事物都尽可能机械化。如果你的团队对于如何命名需要判断或仔细思考的规则，那么这些规则就不会奏效。不同的程序员会做出不同的决策，每个人的命名都会不同。

你更愿意大家自然而然地选择相同的名称来表示同一个东西，因为这使得与大家的代码工作变得更加容易。而创建这种一致性的最简单方法就是制定每个人都遵守的机械化规则。

Sucker Punch关于变量命名的规则特别机械化。我没有在本书的例子中使用它们，主要是为了易接受性。我们的规则对我们自己很有效，但那是因为我们所有人都在不断地遵循它们。如果你第一次见到这些规则，它们可能看起来有些奇怪。

相反，我在本书的例子中使用了更温和的约定——如果我有一个表示角色的类，那么这个类的名称就叫做Character，而保存角色的变量通常被命名为character，而一个充满角色的向量就被命名为characters。这些简单的约定是为了可读性而选择的，但一直被保持一致使用。

与此相似，Sucker Punch的代码库也采用了类似的规则，只不过规则更为详细，而且稍微有些简洁。我们使用了微软的匈牙利命名标准的变体。这是...有争议的。Sucker Punch的程序员使用起来相当快速地适应了，但匈牙利命名标准在微软生态系统以外，通常是被人嘲笑的对象。

匈牙利标准的核心思想是，变量的类型（或有时是用途）机械地确定了变量名的全部或部分。如果你有一个用于访问数组中派系的索引，那么该变量的名称就被命名为iFaction。如果你有一个指向字符的指针向量，那么该变量的名称就被命名为vpCharacter。

在许多情况下，这就是整个故事的全部。变量名是完全机械化的，因此每个人都使用了完全相同的变量名。这就是我们所期望的！

如果你有多个具有相同类型的变量，你可以在变量名的末尾添加一个限定词。如果你有两个字符指针，它们可能被称为pCharacter和pCharacterOther。这确实会引入判断问题，但我们对常见限定词模式的约定可限制引入的不一致性。

重要的不是我们命名约定的细节，而是我们有严格的约定，它们尽可能地机械化，并且它们都有良好的文档和执行。这使我们处于一个幸福的状态，每个人选择相同的名称表示相同的事物，并且使用别人的代码感觉就像使用自己的一样。

找出你自己项目中可以做得更机械的约定，并去做。你将在未来的多年中受益。
