# 规则4：泛化至少需要三个例子

我们所有新手程序员都被教导，通用解决方案比特定的解决方案更佳。最好写一个函数解决两个问题，而不是为每个问题编写单独的函数。

你不太可能写出这样的代码：

```go
```

但是，更简单的代码就可以实现同样的功能：

```go
```

这种以通用化为基础的思考方式是很自然的，特别是对于如此简单的例子来说。如果你需要找到世界上所有红色的标志，作为程序员，你自然而然地想到编写代码来查找任意颜色的标志，然后将红色作为该颜色传递进去。自然界讨厌真空，程序员们讨厌只解决一个问题的代码。

值得思考的是，为什么这种方式感觉如此自然。在某种程度上，编写findSignByColor而不是findRedSign的本能，基于一种预测。考虑到你正在寻找红色的标志，你可以自信地预测，你最终还会要寻找蓝色标志并编写处理该情况的代码。

实际上，为什么要止步于此？不如编写一个更通用的解决方案来查找标志？

你可以创建一个更通用的接口，让你查询标志的任何方面，如颜色、大小、位置、文本——这样通过颜色查找标志就只是一个特殊的子情况。你可以通过创建一个定义标志每个方面的可接受值的结构来实现这一点：


```go
```

设计查询参数需要进行某些判断调用，每个方面都会强制使用不同的查询模型。在这个例子中，我所做的判断调用是：

    - 可以提供一系列可接受的颜色，而不是指定单个颜色。空列表表示任何颜色都可接受。
	- 在内部，Location将纬度和经度存储为浮点数，因此查找精确匹配并不实用。相反，您将指定距某个位置的最大距离。
	- 您可以使用正则表达式来匹配标志的文本或部分文本，这将处理很多显而易见的情况。

实际找到匹配标志的代码很简单：

```go
```

使用这个模型找到一个红色的标志仍然非常简单——创建一个SignQuery，指定红色为唯一可接受的颜色，然后调用findSign：

```go
```

请记住，SignQuery的设计基于一个例子：查找单个红色标志。其他的都是推测。在这一点上，没有其他的例子可以依据，所以你只是在预测你需要找到其他类型的标志。

这就是问题所在——你的预测很可能是错误的。如果你很幸运，那么它们只会稍微有些出入，但是你很可能不会那么幸运。

## YAGNI（你可能永远不需要）

最明显的是，您会预测并解决实际上从未发生的情况。也许前几个查找标志的用例看起来像这样：

	- 查找一个红色标志。
	- 查找靠近Main Street和Barr Street拐角处的标志。
	- 查找212 South Water Street附近的红色标志。
	- 查找一个绿色标志。
	- 查找902 Mill Street附近的红色标志。
	
你可以使用SignQuery和findSign解决所有这些情况，因此从这个意义上说，代码做得相当不错，预测了使用案例。但我没有看到任何情况下你接受多个标志颜色，也没有任何一个使用案例查看标志的文本。所有实际的使用案例都只找单一颜色标志，最多限制于位置。SignQuery代码解决了实际上并未出现的情况。

“这是一个常见的模式，足够常见，以至于Extreme Programming哲学为其取了一个名字——YAGNI，即“您可能永远不需要它”。您所做的工作是定义可接受颜色列表，而不是已知用例中的单一颜色吗？浪费了时间和精力。您对C++正则表达式类进行的实验，想要区分完整匹配和部分匹配？这是你无法回收的时间。

更重要的是，SignQuery的额外复杂性对任何使用它的人都会造成成本。使用findSignByColor函数的方法非常明显，但findSign需要更多的调查。毕竟，它包含三种不同种类的查询模型！

正则表达式的部分匹配是否足够，还是表达式需要匹配标志的全部文本？这三个条件如何相互作用并不明显，这是“和”还是“或”？如果阅读代码，显然只有当所有条件都匹配时，标志才与查询匹配，但那需要阅读代码。这引入了一个新的混淆——哪些SignQuery字段是必需的？根据当前的编写方式，直接从构造函数传递一个空查询会匹配所有标志，因此只需要设置您正在过滤的字段——但学习这一点需要一些调查。

鉴于现实世界使用案例中的明显模式，最好只解决实际问题：


```go
```

你现在可能会指责我作弊。当然，在第一批使用案例出现后，似乎findSignWithColorNearLocation是一个比SignQuery更好的解决方案——但是你在第一个使用案例后无法预测这一点。将findSignWithColorNearLocation编写为通用解决方案并没有比编写SignQuery更有可能成功。其中一个用例可能允许多种颜色或可能涉及标志的文本。

这正是我的观点！在一个用例之后，没有任何通用解决方案可以预测，因此尝试编写一个是错误的。findSignWithColorNear​Loca⁠tion和SignQuery都是错误的。这里没有赢家，只有两个失败者。

以下是找到红色标志的最佳方法：

```go
```

是的，我是认真的。我可能会传递要匹配的颜色，但这就是我会做到的。如果你有一个使用案例，写代码来解决这个使用案例。不要尝试猜测第二个使用案例是什么。编写代码来解决你理解的问题，而不是你猜测的问题。

## 对这种策略的明显反对意见，我加倍回应

“等等，”你可能会说。“编写仅满足使用案例要求的代码，这样不是保证你会遇到代码无法处理的使用案例吗？当出现下一个不适合你编写的代码的使用案例时，你该怎么办？这似乎是不可避免的。

这不是说明要编写更通用的代码吗？当然，我们用SignQuery遇到的前五个使用案例没有涵盖我们编写的所有代码，但是如果第六个使用案例涵盖所有的代码，我们是否会很高兴已经编写并准备好了SignQuery代码？

不，其实不是。节省你的工作。当一个使用案例出现，你的代码无法处理它时，编写代码来处理它。你可以复制和粘贴你的第一次尝试，并进行调整以处理新的使用案例。你可以从头开始再做一次。这两种方法都可以。

在五个使用案例列表中的第一个是“找到一个红色的标志”，我写了代码来做到这一点，且仅仅是这一点。第二个使用案例是“找到Main Street和Barr Street角落附近的标志”，因此现在我将编写恰好满足此要求的代码：

```go
```

第三个使用案例是“找到212 South Water Street附近的红色标志”，这并没有被我编写的两个函数处理。这就是拐点——现在我们有了三个独立的使用案例，开始可以考虑通用性。有了三个独立的使用案例，我们更有信心预测第四个和第五个使用案例。

为什么是三？什么使三成为一个魔法数字？实际上没有什么，除了它不是一个或两个以外。一个示例不足以猜测一般模式。根据我的经验，两个通常也不行——两个示例后，你只会对你的不准确“概括”更有信心。通过三个不同的示例，你对模式的预测将更准确，并且在概括时你可能会更保守。例如，在第一和第二个示例之后被证明错误的情况，这会让你谦虚！

然而，现在还没有必要通用化！完全可以编写第三个函数，而不将前两个函数合并到其中：

```go
```

这种将功能分成三个独立的函数的方法有一个重要的好处——函数非常简单。很明显该调用哪一个函数。如果你有颜色和位置，请调用findSignWithColorNearLocation。如果你只有颜色，就是findSignWithColor；如果你只有位置，就是findSignNearLocation。如果你的寻找标志用例继续检查单一的颜色和/或位置，那么这三个函数将永远正常工作。当然，这种方法在扩展性方面并不优秀——如果有更多的可能参数，通过两个独立参数和三个独立的findSign函数，这种方法并不糟糕，但如果参数更多，它很快就变得荒谬。如果您在某个时候有一个涉及查看标志文本的用例，您可能会回避创建七个findSign函数的变化。

在此时，将三个findSign函数合并成一个函数来处理这三种情况是没有问题的。一旦你有了三个独立的使用案例，通用化就更加安全。但是，只有在你手头的使用案例上，基于编写和阅读代码是否更容易，才进行通用化。永远不要因为你担心下一个使用案例而进行通用化——只在你知道的使用案例上进行通用化。

为此，在C ++中编写通用化代码有点困难，因为C ++实际上没有可选参数，只有参数的默认值。这意味着发明一些方法来将我们的参数标记为“不存在”。一个解决方案是添加一个Invalid值来表示颜色和位置，以用于我们不关心它们的情况。以下是findSignWithColorNearLocation的第一个版本的重复内容：


```go
```

有了这个函数，所有调用findSignWithColor和findSignNearLocation的代码都可以替换为调用findSignWithColorNearLocation。

## 实际上比YAGNI更糟糕

到目前为止，您已经看到过早地通用化意味着您可能编写永远没有使用的代码，这是不好的。不太明显的问题是，过早地通用化使得难以适应未预期的用例。这部分是因为您编写的通用代码更加复杂，因此需要更多的工作来调整，但还有更微妙的问题。一旦您为通用化建立了模板，您很可能会扩展该模板以用于未来的用例，而不是对其进行重新评估。

让我们回到过去，假设您早期使用了SignQuery类进行通用化，但这次前几个使用案例看起来像这样：
    
- 找到一个红色的标志。
- 找到一个位于Main Street和Barr Street拐角处附近的红色“STOP”标志。
- 查找Main Street上所有红色或绿色的标志。
- 查找Wabash Avenue或Water Street上所有白色标志上标注为“MPH”的文本。
- 在902 Mill Street附近查找文本为“Lane”或蓝色的标志。

在这个列表中，前两个用例非常适合SignQuery，但之后的内容开始分崩离析。


第三个用例“在Main Street上找到所有红色或绿色的标志”增加了两个新的要求。首先，代码需要返回所有匹配的标志，而不是单个标志。这不难：

```go
```

第二个新要求是查找街道上的所有标志，这就比较棘手了。假设街道可以表示为连接位置的一系列线段，那么位置和街道都可以打包到一个新的Area结构体中：

```go
```

然后，新的Area结构体可以替换SignQuery中的位置和最大距离：

```go
```

第四个用例要求在两条街上查找所有限速标志，这不适合。很容易支持区域列表：

```go
```

然后，您可以用列表替换SignQuery中的单个区域：

```go
```

用例五实际上将事情搅和了 - 它正在寻找标记历史遗迹的标记。这些标志通常是蓝色的，因此它寻找蓝色的标志，但也可能是绿色的特定文本。这不适合SignQuery中的模型。

同样，这并不是不可能的。将布尔运算添加到SignQuery可以解决新的用例：

```go
```

呼，这是一个比我们在本章开始时看到的用例更为苛刻的用例集。尽管做出了很多变化，但QuerySign模型仍然可以处理广泛的请求。仍然存在无法回答的合理请求，比如“在彼此距离不到10米的位置找到两个标志”，但很容易想象我们已经涵盖了重要的情况。胜利，对吗？

## 这不像成功

事实上，即使我非常谨慎公正，尽力使一切保持整洁，对于如此扩展SignQuery这么多，这并没有让我们处于一个好位置。

当你不断扩展通用解决方案时，你可能会失去对上下文的看法。这正是在这里发生的事情。

让我们比较使用SignQuery解决最后一个用例与直接完成相同任务的情况。这是SignQuery的解决方案： 

```go
```

这里是直接版本的代码：

```go
```

直接的解决方案更好。它更简单、更易于理解、更易于调试、更易于扩展。我们在SignQuery上所做的所有工作只会让我们离最简单和最好的答案越来越远。这就是过早概括的真正危险之处，不仅仅是你会实现永远不会被使用的功能，而是你的泛化会确定一个难以改变的方向。

泛化解决方案真的非常“粘”。一旦你建立一个抽象来解决一个问题，就很难想到其它的替代方法。一旦你使用findSigns来查找所有红色标志，你的本能反应就是每当你需要查找任何种类的标志时都使用findSigns。函数的名称就告诉你要这么做！

因此，如果你有一个不完全匹配的情况，显而易见的答案是扩展SignQuery和findSigns以涵盖新情况。对于下一个不匹配的情况和之后的情况也是如此。随着通用解决方案变得更加具有表现力，它也变得更加繁琐…除非你非常小心，否则你甚至不会注意到你已经将通用化推广到了其自然界限以上。

当你手握一把锤子时，所有东西都看起来像钉子，对吧？ 创建一个通用解决方案就像是在发放锤子。 在你确定你手中拿着的是钉子而不是螺丝时，请勿这样做。
