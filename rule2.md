# 规则2：Bug是具有传染性的

编程中有一条谚语：发现bug的越早，修复它就越容易。这通常是正确的...但我认为更正确的说法是：发现 bug 越晚，修复它就越痛苦。

一旦 bug 存在，人们将无意中编写依赖于该 bug 的代码。有时这个不太稳定的、依赖于 bug 的代码在附近，与 bug 所在的系统在同一个地方。有时它并不在附近-也许是在下游，在调用你的系统并依赖于你的 bug 引起的不正确结果的代码中。或者它在上游——一起协同工作的代码，因为bug使你以特定的方式调用它。

这是一件自然的事情——不可能避免。我们会注意到出现问题的事情，而不是正常运作的事情。当发生问题时，我们会进行调查以找出原因。但是，当事情进展顺利时，我们并不会进行调查。如果你的代码工作正常，或者看起来工作正常，那么自然会有一种倾向，认为它以你认为的方式工作，但往往它工作的原因你从未想象过。由于你不进行调查，你永远不会发现导致你的代码意外工作的纠结情况。

这对你编写的代码和其他人编写的调用你的代码的代码都成立。当你向团队的代码库提交一个bug时，代码库将慢慢但不可避免地积累其他依赖于你的bug的代码。这些隐蔽的纠缠只有在你修复一个明显的bug并且项目的其他部分神秘地停止工作时才会变得可见。

你越早发现bug，这些相互纠缠的部分就会越少时间生长。这意味着需要清理的依赖关系更少——这通常是修复一个bug最耗时的部分。很常见的情况是，处理bug修复的后果所花费的时间比修复bug本身还多。

将bug看作具有传染性是有用的。你系统中的每一个bug都倾向于创建新的bug，因为新代码绕过bug或依赖于其不正确的行为。阻止由此产生的传染最好的方法是尽早消除bug，避免它们的恶劣影响扩散。

## 不要指望你的用户

好的，我们想要尽早检测到问题。我们该怎么做？

有一件事你不能指望——你的用户。无论是团队成员调用你的代码还是顾客使用你的功能，用户都不是一个很好的第一道防线。当然，有时他们会报告问题，但更经常的情况是他们会认为他们观察到的行为是你打算的行为。这就是相互纠缠的来源-未被注意到的问题，当然，也有被注意到但后来被认为是设计的一部分的问题。

你可以尝试改善这一点。你可以编写更好的面向用户的文档。你可以把你的团队拉到会议室里，向他们解释一个新系统或功能。你可以维护一个最新信息的内部wiki，介绍一切如何组合在一起，或者在你的支持网站上放一个技术说明。这些事情都是值得的，它们都会有所帮助，尽管代价不小，效果有所不同，但它们并不能解决问题。根本上，你的用户不会像你一样了解你的意图，因此无论你做什么，他们都会认为bug是功能。

一个更好的答案是某种形式的持续自动化测试。大多数程序员都认为自动化测试是一件好事。至少，程序员认为自动化测试是其他程序员要做的好事，无论他们自己是否愿意做。

关于连续自动化测试的想法有许多自制的变体，以及更为正式的方法学，如测试驱动开发。

一般来说，这个想法是你的系统（或者更好地说，整个项目）有一组测试，你可以快速方便地运行它们，彻底地练习系统（或者项目）并报告问题。如果测试真正快捷方便，它们就会被经常执行——比如每次你编译或运行项目时。任何早期出现的bug都很容易解决。如果测试只是理论上快捷方便，它们往往会作为提交流程的一部分运行，这仍然足够早，可以避免使bug难以修复的纠缠增长。

这种类型的测试是昂贵的。编写某个代码片段的测试可能需要与编写代码本身一样多的时间。然而，自动化测试的支持者会（令人信服地！）认为这是一种错觉。毕竟，编写那段代码的隐藏成本是以后检测和诊断问题时的时间成本，当时它们难以修复。编程就是调试，对吧？测试支持者认为，事先进行测试是更快的——甚至，如果你是一个狂热者，在编写它打算测试的代码之前编写测试可能更快。

持续自动化测试不是你可以轻易采用的个人实践。要使它起作用，需要投资相当多的基础设施——你需要一个非侵入式的测试框架、一个测试友好的“部署系统”，以及一个信奉自动化测试理念的团队。除非整个团队都认同，否则你就在逆流而行。但如果你在一个支持自动化测试的团队中，那就太好了！

尽管测试为中心的方法显然具有很大的价值，但我们在Sucker Punch还没有全面采用这种方法。我们确实为许多系统编写了自动化测试，但它们共同覆盖了我们代码库的一小部分。为什么呢？

## 自动化测试可能有些棘手

有些项目和问题比其他的更适合自动化测试。

有些东西很难测试，要么是因为很难涵盖所有可能的输入，要么是因为很难验证输出。想象一下你正在编写一种新的有损音频压缩编解码器。你如何编写一个自动化测试呢？

验证压缩器不崩溃很容易，或者针对某些测试文件集合来测量压缩量。但验证解压音频是否真正像原始音频那样听起来并不容易。你正在编写音频压缩编解码器，所以你可能有足够的信号处理数学来编写检测明显问题的测试，但在某些时候，你需要在人类耳朵上戴上耳机，要求人们从三个选项中选择压缩后的样本。这不是一个可以快速或方便地运行的测试。

有些代码本质上很难测试，因为其成功很难衡量——Sucker Punch编写的很多代码都符合这一特点。商贩角色是否像真正的商贩一样行事？那个面部动画是否真正表现出厌恶，或者这个角色只是看起来要打嗝？虽然你只是握着控制器，但这个过程是否感觉就像射箭一样？

如果你正在开发有大量难以测试的代码块的项目，那么你将被迫使用混合模型。测试你可以测试的，控制你可以控制的，并记住你不会测试所有部分。任何没有被自动化测试覆盖的区域都需要进行手动测试：相应进行计划。

话虽如此，你可以构建你的代码以使测试变得更容易。

想象一下，你要编写一份外部自动化测试的代码片段——也就是说，是一些与你正在编写的代码分离出来的测试代码，它将用一系列旨在检查代码性能的输入来调用你的代码，然后检查输出是否符合预期。你可以如何构建你的代码，以使这个测试变得更容易编写吗？

## 无状态代码更容易测试

一个重要的策略是减少代码中的状态量。如果代码不依赖于状态，那么测试会变得容易得多。任何一个纯函数——一个仅依赖于其直接输入、没有副作用且结果是可预测的代码片段——都很容易测试。最好是这样： 