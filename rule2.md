# 规则2：Bug是具有传染性的

编程中有一条谚语：发现bug的越早，修复它就越容易。这通常是正确的...但我认为更正确的说法是：发现 bug 越晚，修复它就越痛苦。

一旦 bug 存在，人们将无意中编写依赖于该 bug 的代码。有时这个不太稳定的、依赖于 bug 的代码在附近，与 bug
所在的系统在同一个地方。有时它并不在附近-也许是在下游，在调用你的系统并依赖于你的 bug
引起的不正确结果的代码中。或者它在上游——一起协同工作的代码，因为bug使你以特定的方式调用它。

这是一件自然的事情——不可能避免。我们会注意到出现问题的事情，而不是正常运作的事情。当发生问题时，我们会进行调查以找出原因。但是，当事情进展顺利时，我们并不会进行调查。如果你的代码工作正常，或者看起来工作正常，那么自然会有一种倾向，认为它以你认为的方式工作，但往往它工作的原因你从未想象过。由于你不进行调查，你永远不会发现导致你的代码意外工作的纠结情况。

这对你编写的代码和其他人编写的调用你的代码的代码都成立。当你向团队的代码库提交一个bug时，代码库将慢慢但不可避免地积累其他依赖于你的bug的代码。这些隐蔽的纠缠只有在你修复一个明显的bug并且项目的其他部分神秘地停止工作时才会变得可见。

你越早发现bug，这些相互纠缠的部分就会越少时间生长。这意味着需要清理的依赖关系更少——这通常是修复一个bug最耗时的部分。很常见的情况是，处理bug修复的后果所花费的时间比修复bug本身还多。

将bug看作具有传染性是有用的。你系统中的每一个bug都倾向于创建新的bug，因为新代码绕过bug或依赖于其不正确的行为。阻止由此产生的传染最好的方法是尽早消除bug，避免它们的恶劣影响扩散。

## 不要指望你的用户

好的，我们想要尽早检测到问题。我们该怎么做？

有一件事你不能指望——你的用户。无论是团队成员调用你的代码还是顾客使用你的功能，用户都不是一个很好的第一道防线。当然，有时他们会报告问题，但更经常的情况是他们会认为他们观察到的行为是你打算的行为。这就是相互纠缠的来源-未被注意到的问题，当然，也有被注意到但后来被认为是设计的一部分的问题。

你可以尝试改善这一点。你可以编写更好的面向用户的文档。你可以把你的团队拉到会议室里，向他们解释一个新系统或功能。你可以维护一个最新信息的内部wiki，介绍一切如何组合在一起，或者在你的支持网站上放一个技术说明。这些事情都是值得的，它们都会有所帮助，尽管代价不小，效果有所不同，但它们并不能解决问题。根本上，你的用户不会像你一样了解你的意图，因此无论你做什么，他们都会认为bug是功能。

一个更好的答案是某种形式的持续自动化测试。大多数程序员都认为自动化测试是一件好事。至少，程序员认为自动化测试是其他程序员要做的好事，无论他们自己是否愿意做。

关于连续自动化测试的想法有许多自制的变体，以及更为正式的方法学，如测试驱动开发。

一般来说，这个想法是你的系统（或者更好地说，整个项目）有一组测试，你可以快速方便地运行它们，彻底地练习系统（或者项目）并报告问题。如果测试真正快捷方便，它们就会被经常执行——比如每次你编译或运行项目时。任何早期出现的bug都很容易解决。如果测试只是理论上快捷方便，它们往往会作为提交流程的一部分运行，这仍然足够早，可以避免使bug难以修复的纠缠增长。

这种类型的测试是昂贵的。编写某个代码片段的测试可能需要与编写代码本身一样多的时间。然而，自动化测试的支持者会（令人信服地！）认为这是一种错觉。毕竟，编写那段代码的隐藏成本是以后检测和诊断问题时的时间成本，当时它们难以修复。编程就是调试，对吧？测试支持者认为，事先进行测试是更快的——甚至，如果你是一个狂热者，在编写它打算测试的代码之前编写测试可能更快。

持续自动化测试不是你可以轻易采用的个人实践。要使它起作用，需要投资相当多的基础设施——你需要一个非侵入式的测试框架、一个测试友好的“部署系统”，以及一个信奉自动化测试理念的团队。除非整个团队都认同，否则你就在逆流而行。但如果你在一个支持自动化测试的团队中，那就太好了！

尽管测试为中心的方法显然具有很大的价值，但我们在Sucker Punch还没有全面采用这种方法。我们确实为许多系统编写了自动化测试，但它们共同覆盖了我们代码库的一小部分。为什么呢？

## 自动化测试可能有些棘手

有些项目和问题比其他的更适合自动化测试。

有些东西很难测试，要么是因为很难涵盖所有可能的输入，要么是因为很难验证输出。想象一下你正在编写一种新的有损音频压缩编解码器。你如何编写一个自动化测试呢？

验证压缩器不崩溃很容易，或者针对某些测试文件集合来测量压缩量。但验证解压音频是否真正像原始音频那样听起来并不容易。你正在编写音频压缩编解码器，所以你可能有足够的信号处理数学来编写检测明显问题的测试，但在某些时候，你需要在人类耳朵上戴上耳机，要求人们从三个选项中选择压缩后的样本。这不是一个可以快速或方便地运行的测试。

有些代码本质上很难测试，因为其成功很难衡量——Sucker
Punch编写的很多代码都符合这一特点。商贩角色是否像真正的商贩一样行事？那个面部动画是否真正表现出厌恶，或者这个角色只是看起来要打嗝？虽然你只是握着控制器，但这个过程是否感觉就像射箭一样？

如果你正在开发有大量难以测试的代码块的项目，那么你将被迫使用混合模型。测试你可以测试的，控制你可以控制的，并记住你不会测试所有部分。任何没有被自动化测试覆盖的区域都需要进行手动测试：相应进行计划。

话虽如此，你可以构建你的代码以使测试变得更容易。

想象一下，你要编写一份外部自动化测试的代码片段——也就是说，是一些与你正在编写的代码分离出来的测试代码，它将用一系列旨在检查代码性能的输入来调用你的代码，然后检查输出是否符合预期。你可以如何构建你的代码，以使这个测试变得更容易编写吗？

## 无状态代码更容易测试

一个重要的策略是减少代码中的状态量。如果代码不依赖于状态，那么测试会变得容易得多。任何一个纯函数——一个仅依赖于其直接输入、没有副作用且结果是可预测的代码片段——都很容易测试。最好是这样：

```go
package rule2

func SumVector(values []int) int {
	sum := 0
	for _, value := range values {
		sum += value
	}
	return sum
}
```

而不是：

```go
package rule2

func Reduce(initialValue int, reduceFunction func(int, int) int, values []int) int {
	reducedValue := initialValue
	for _, value := range values {
		reducedValue = reduceFunction(reducedValue, value)
	}
	return reducedValue
}

```

测试 SumVector，你只需要一组输入和对应输入的期望输出。这正是测试驱动开发框架擅长的领域。如果涉及状态，则需要更复杂的输入集来全面测试代码。

而测试 Reduce 则更难——为了追求通用性，或者将其作为向多线程开发迈出的一步，它会反复调用传入的函数对向量中的值进行操作。当然，你确实可以使用reduce来求和向量中的值。

```go
package rule2

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func sum(value, otherValue int) int {
	return value + otherValue
}

func TestReduce(t *testing.T) {
	assert.Equal(t, 15, Reduce(0, sum, []int{1, 2, 3, 4, 5}))
}

```

但是测试 Reduce 存在问题。谁知道 reduceFunction 函数将会做什么呢？它是否依赖于某个外部状态？如果它有副作用会发生什么？如果调用该函数会从当前正在迭代的值向量中移除某些内容会怎么样？如果你要测试
Reduce，你必须预先考虑并测试所有这些情况。与测试 SumVector相比，这是一组更复杂的测试用例。

要彻底测试代码，你需要为其提供一组全面的状态，然后评估其输出与各个状态的匹配程度。对于纯函数，函数的参数是唯一关心的状态。但是当引入了副作用、内部状态或调用任意函数时，可能关心的状态数量就会爆炸增长。这会迫使你需要做出妥协——你可以接受较少的测试覆盖率，或编写数量难以管理的测试用例。

让我们看一个简单的例子。假设你正在跟踪一个按优先级排序的字符列表。每个字符都有一个优先级，根据该优先级很容易获取一个按该顺序排序的字符列表。该接口非常简单：

```go
package rule2

type Character struct {
	priority int
	index    int
}

var allCharacters []*Character

// 保持 allCharacters 按优先级排序并不难，所有字符都按优先级顺序排列。
// 可以通过分步骤操作来实现，跟踪每个字符在优先级列表中的位置，并在其
// 优先级更改时谨慎地最小化向前和向后移动。这意味着在创建字符时将其插入到正确的位置:

func NewCharacter(priority int) *Character {
	c := &Character{
		priority: priority,
		index:    0,
	}

	index := 0
	for ; index < len(allCharacters); index++ {
		if priority <= allCharacters[index].priority {
			break
		}
	}

	allCharacters = append(allCharacters, c)

	for ; index < len(allCharacters); index++ {
		allCharacters[index].index = index
	}

	return c
}

```

这样做是起作用的，但测试它很复杂。有一些隐藏的状态是外部测试无法接触到的。创建一组按优先级排序的字符然后检查allCharacters是否按正确的顺序返回它们的测试将捕获一些错误，但也会错过一些错误。当前的索引可能会出现问题，即使字符已按正确的顺序排列，使用Character公开的方法也无法检查。不正确的索引可能会导致问题，但无法保证这些问题会很快（甚至永远）出现。而对于三个不同的代码路径，每个路径都尝试保持索引正确，很容易出错。

更简单的方法是测试一个无状态版本的Character，即不尝试维护状态的版本:

```go
```

这里仍然有状态，因为您正在跟踪 allCharacters中的所有字符，但它不是隐藏的。为这个版本的代码编写测试可能不像编写纯函数的测试那样简单，但比起开始的增量版本的Character的测试要简单得多。

在先前的状态方法中，您必须对事情进行排序。没有这个状态，您可以只检查预期的输出并感到非常安全。

这种无状态的代码在第一时间正确编写起来也更容易。这是测试驱动开发的隐藏优势-易于测试的代码往往更容易编写。如果您考虑如何测试即将编写的某个代码块，您最终会编写出更简单的东西。

## 审计您无法消除的状态

假设情况迫使您保留一些状态。也许调用模式鼓励这样做-例如，您的按字符排序的列表看到优先级调整与对AllCharacters的调用交错，而您的无状态实现中的所有排序都正在搅动您的内存缓存。

如果由于无法使用某些内部状态，难以编写外部测试，请编写内部测试。一种容易的方法是在数据上编写审核方法-在这种情况下，编写一个审核功能来检查内部状态是否一致：

```go
```

如果由于无法使用某些内部状态，难以编写外部测试，请编写内部测试。一种容易的方法是在数据上编写审核方法-在这种情况下，编写一个审核功能来检查内部状态是否一致：

```go
```

这种内部测试有其优点，尤其是如果您将内部测试视为对外部测试的补充。通常，您可以始终保持内部测试运行，这意味着它们正在实际的现实测试用例上运行，而不是您为单元测试构建的人工测试用例。

显然，某人必须调用这些内部函数才能让它们有用！一个好的经验法则是在更新字符状态的任何方法的末尾调用Character ::
audit，并在列表更改时调用Character :: auditAll。您可以根据需要增加或减少审核频率。

## 不要相信调用者

在正常编程过程中，你会编写被你团队中其他人调用的代码。即使你只在个人项目上工作，未来的你也会调用你的代码-未来的你可能就像陌生人一样。未来的你不会记得细节，其他的调用者也从未知道。所以不要相信调用者会正确处理细节！

调用者会传递不兼容的参数集。他们会忽略调用期望的初始化函数，他们会忘记调用关闭函数。他们会提供一个回调函数，但实际上并不能实现该函数预期的基本要求。他们会完全搞错……如果你没有检测到错误，那么这些错误也不会被修复。纠缠会变得越来越多，这次不是你的代码中的错误，而是调用代码中的错误。

可能有些违反直觉，但找到这些错误最容易的地方不在调用代码中，而在被调用的代码中。调用者可能会犯错误，但你更有可能发现他们的错误。

现在，通过良好的设计，您通常可以使调用者无法处理细节错误。这是第7条规则，“消除故障情况”的主题。但有时您无法这样做。这些情况应该怎么处理呢？

这里有一个例子。你正在编写一个刚体物理模拟器，它将被公司开发中的三个不同视频游戏使用。你将跟踪内部状态，比如哪些刚体彼此接触，并且该状态必须在某个地方进行存储。但你不能像在标准C++代码中那样调用operator
new。内存很紧，而且你的客户有自己的自定义内存管理器需要与之集成。

有一个简单的答案-让您的客户在初始化步骤中交出分配和释放所需内存的函数。我很想先展示一些错误的初始化示例，但我会直接跳到一个不错的示例。如果您实际上正在编写刚体物理模拟器，则可能具有比下面代码片段中命名的两个更多的初始化参数。例如，重力常数。将所有初始化参数收集到单个结构中，然后将其传递给单个初始化函数：

```go
```

暴露用于将新的模拟刚体添加和删除到系统中的方法，并暴露获取和设置它们当前状态的方法：

```go
```

预期的使用模式非常明显，对吧？在使用模拟器之前进行初始化，在完成后关闭它。添加对象，操纵它们，并在完成后销毁它们。没有什么复杂的。

但是你不能相信调用者连简单的细节都会搞错。他们会忘记调用初始化，会请求已删除的对象的状态，或者会尝试在你从未分配过的随机ObjectID上设置对象状态。

这时候，诱人的做法是忽略这些情况-假设人们会正确处理细节，并让情况自然而然地发展-但那是一个巨大的错误。如果你没有检测到错误并以某种方式报告它，事情将以泪水告终。调用者可能不会注意到他们的错误，或者他们会认为观察到的行为是一个特性。

想象一下，你已将ObjectID实现为一个包装器，它围绕一个更小的整数并用作线性ObjectState结构列表的索引：

```go
```

这种设计非常简单易懂，但非常不稳定。它会使调用者犯的易错错误未被注意到。在销毁对象之后尝试获取对象状态，结果将是未定义的。

实际上，这有点误导人，尽管人们通常是这样谈论这样的接口。他们的意思是在调用getObjectState获取已删除对象的状态时，接口不承诺任何特定的结果-但在实际中，结果是完全定义的！在实现中（我没有向你展示），如果你在使用destroyObject销毁对象之后立即调用getObjectState，你会得到该对象在删除之前具有的状态。很容易假定这是预期的行为，无论是隐式还是显式的，并且从这样的假设中，纠缠就会增长。

未定义的结果是接口设计不良的标志。

不要让这种不正确的使用被忽视。任何调用destroyObject后调用getObjectState的人都应该得到关于此的反馈，但首先您需要检测问题。一个简单的解决方案是将ObjectID中的索引与“代数”号码一起使用：

```go
```

使用代数号码可以检测对象ID的不正确使用。当您创建或销毁对象时，增加其代数版本号码。如果您尝试销毁一个对象，然后获取其状态，代数将不匹配，这个不匹配将被报告。调用者被通知他们犯了一个错误，并可以在问题滋生之前纠正它。

您可以很容易地添加检查我已经识别的其他使用错误的代码-例如忘记调用初始化或调用两次。在前面的代码中，接口重新设计了一下，使其更难创建无效的对象ID-唯一的公共构造函数创建一个有效的对象ID，因此调用者只有易于访问的已正确构造和返回的对象ID。

关于如何标记这种使用错误，有一个合理的讨论-您可以使用断言，但您也可以轻松地返回错误代码或抛出异常。您的回答将取决于您团队的惯例。重要的是您要标记错误，而不是您如何标记错误。

## 保持代码健康

更容易测试的代码或更好地自我测试的代码可以更长时间保持健康。最好是从一开始就考虑这一点，在为项目的某个新部分编写第一行代码之前就开始考虑。您可以从编写自动化测试开始，就像测试驱动开发一样。您也可以选择实现功能的无状态方式，或者添加对代码功能的持续内部审核。

结果是在这些致命的错误还没有扩散之前，能够及早地发现和解决这些错误。这意味着需要修复的问题更少，修复问题时也更容易解决。

而且还有一个隐藏的好处！大部分能够使代码易于测试的技术也能使代码更易于编写——不得不为所有使用情况编写测试会促使你将其简化为更少的使用情况。消除状态可减少棘手的代码。使界面不易出错可使其更简单。

这是一种双赢的局面。因此，请保持简单，并继续测试。