# 第七条规则：消除失败情况

这个标题听起来很乐观，对吗？它甚至是什么意思？

有些失败情况是不可避免的，对吧？如果我试图打开一个文件，那么这个文件可能不存在，或者被其他用户锁定。没有任何界面设计巧妙的方法可以避免打开文件失败的可能性。所以这不可能是它的含义。这一定更多地是关于消除那些实际上是可以避免的失败情况，而不是内在于文件操作的东西——可能是像在关闭文件句柄之后写入文件，或者在完全初始化之前调用对象中的方法这样的用法错误。

也许我可以设计一些系统，使其不可能出现使用错误，但这听起来并不容易。而且确实如此。设计一个不可能被误用的系统是相当困难的。如果你向用户公开一个功能，他们会发现一种古怪的方法来使用它，最终导致一切都崩溃，就像用Minecraft方块完全构建一个8位处理器。

如果你向团队中的其他程序员公开一个功能，他们会误用它。这种误用可能是有意的，是为了让某些东西起作用——比如，在调用文件系统关闭例程后关闭文件句柄，因为这是避免不想要的回调的唯一方法。更有可能是完全无意的，是对你的接口调用方式的误解。

你需要自问的关键问题是：“我让这个功能或接口的用户自我伤害的难度有多大？”

当然，正确答案是“非常困难”，但我们经常会创建使无意使用变得容易的功能或接口。

如果一个特性或接口容易被误用，那么错误就是不可避免的。某种程度上，错误已经设计到了该特性或接口中。我们想做的是将错误设计出去，而不是设计其中的错误。但首先让我们来看一些设计了失败情况的函数的示例。

## 一个让我容易自我伤害的函数

每个C程序员都至少知道一个易错的函数的例子：printf。printf的设计存在一个根本性问题——它期望给出的格式字符串与传递的参数类型匹配，如果两者不一致就会发生不确定的混乱。

这段代码可以正常工作，因为类型匹配：